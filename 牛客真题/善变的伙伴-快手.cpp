/*
题目描述
又到了吃午饭的时间，你和你的同伴刚刚研发出了最新的GSS-483型自动打饭机器人，现在你们正在对机器人进行功能测试。
为了简化问题，我们假设午饭一共有N个菜，对于第i个菜，你和你的同伴对其定义了一个好吃程度（或难吃程度，如果是负数的话……）A[i]，
由于一些技（经）术（费）限制，机器人一次只能接受一个指令：两个数L, R——表示机器人将会去打第L~R一共R-L+1个菜。
本着不浪费的原则，你们决定机器人打上来的菜，含着泪也要都吃完，于是你们希望机器人打的菜的好吃程度之和最大
然而，你善变的同伴希望对机器人进行多次测试（实际上可能是为了多吃到好吃的菜），他想知道机器人打M次菜能达到的最大的好吃程度之和
当然，打过一次的菜是不能再打的，而且你也可以对机器人输入-1, -1，表示一个菜也不打
输入描述:
第一行：N, M

第二行：A[1], A[2], ..., A[N]
输出描述:
一个数字S，表示M次打菜的最大好吃程度之和
示例1
输入
复制
7 2
1 2 3 -2 3 -10 3
输出
复制
10
说明
[1 2 3 -2 3] -10 [3]
示例2
输入
复制
7 4
1 2 3 -2 3 -10 3
输出
复制
12
说明
[1 2 3] -2 [3] -10 [3]

第四次给机器人-1, -1的指令
备注:
N <= 10^5 = 100000

|A[i]| <= 10^4 = 10000

10%数据M = 1

50%数据M <= 2

80%数据M <= 100

100%数据M <= 10^4 = 10000
*/

//优化了一下通过答案中“流淌201711202027933”的解法，主要是给二维dp直接赋初值，这样可以减少一个循环
//同时增加了一些注释，提高可读性
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
vector<int>ss;
int dp[2][100005]={0};
int main()
{
    int N, M,sum,h,  k, count, now; //N表示菜的个数，M表示机器人最多打菜的次数，cout表示菜的总的好吃度，now表示当前这道菜的好吃度
    cin >> N >> M;
       
    count = 0; 
    while (N--) {
        cin >> now;  //输入菜的好吃程度
        if (count>0) {  //总的好吃度为正时
            if (now >= 0)  //好吃度为正，累加好吃度
                count += now;
            else {
                ss.push_back(count);   //好吃度为负，把之前总的好吃度存下来，并更新总的好吃度
                count = now;
            }
        }
          
        else if (count<0) {  //总的好吃度为负数时
            if (now >= 0) {
                    ss.push_back(count);  //当前好吃度为正，把之前总的好吃度存下来，并更新总的好吃度
                count = now;
            }
            else
                count += now;   //好吃度为负，累加好吃度
        }
          
        else
            count += now;   //总的好吃度为0时，累加好吃度
    }
      
    if (count>0)   //完成数据输入后，总的好吃度如果为正，那么存下来
    {
        ss.push_back(count);
    }
    /*
    上面代码干的活其实简单理解就是把菜的好吃度进行简单的处理：遇到连着正的或者连着负的就累加
    举几组例子方便理解：
    输入：7 7 【1 2 3 -2 3 -10 3】
    输出ss:[6 -2 3 -10 3]
    输入：10 1 【-1 2 4 -3 5 -7 11 24 -6 -9】
    输出ss:[-1 6 -3 5 -7 35]
    输入：6 1 【1 -2 -3 -4 -5 -6】
    输出ss：[1]
    输入：7 1 【1 -1 -2 -3 -4 2 3】
    输出ss：[1 -10 5]
    这样做的目的可以有效减少接下来二维dp的运算量
    否则本题直接用dp会因为运算量过大只通过80%的测试案例
    */
      
    sum = 0;
   
        N = ss.size()+1;
        count = 0;
    //可操作次数大于存储下来的总好吃值个数，直接把正的都取出来累加就是最终的总的好吃度
    if(N<=M){
        for (int j = 0; j < N; j++){
            if(ss[j]>0)
                count+=ss[j];
        }
        return 0;
    }
      
    //可操作次数小于存储下来的总的好吃值的个数，转换为二维dp
    else{
        for (int i = 1; i <= M; i++) {
            sum = 0;
            k=i&1;
            h=(i-1)&1;
            dp[k][0] = 0;
            for (int j = 1; j < N; j++) {
                sum = max(sum, dp[h][j - 1]);
                dp[k][j] = max(sum , dp[k][j - 1]) + ss[j-1];
            }
        }
        for(int i=M;i<N;i++)
        if (count < dp[k][i])
                    count = dp[k][i];
    }
        cout << count << endl;
   
       
    return 0;
   
}