---
title: "KickStart-2019 B轮解题"
catalog: true
toc_nav_num: true
date: 2019/7/17 11:30:00
header-img: "/img/article_header/article_header.jpg"
tags:
- KickStart
- 算法
catagories:
- KickStart
---

### Building Palindrome
这道题看上去简单，但实际上第二个case的数据量还是非常大的。

可以想到的是，一段字符能不能构成回文，必然满足以下条件：
- 所有不同字符的出现个数为偶数
- 一种字符出现个数为奇数，其余字符出现个数为偶数

这样便清楚了，我一开始使用的做法是讲substr排序，遍历点一遍数字。这样的复杂度是O(N),整体的复杂度是O(N*Q)。但是这样只能过第一个case。

实际上在解后面的Q line的问题时，使用的是同一个字符串。所以我们可以先算出所有字符出现的次数，用nums[i]记录从0到i所有字符串出现的次数，动态规划。后面求得时候直接取差值就可以了。

[代码 github](https://github.com/CrowFea/CodeRepo/tree/master/KickStart/2019%20B)

### Energy stones
这道题目看起来考虑的问题比较多，相对复杂。可以从实际情况除法考虑一下。

当两个石头的能量一样，时间一样时，应该先吃衰减快的那个。所以可以按衰减的速度进行排序。这样做是不太正确的，因为有的石头本身基数大，即使衰减的快也比其他石头能量多。所以我们可以看整体的损失量。

假设石头stone[i]，stone[j]。如果先吃i，那么损失的时间是stone[i].s*stone[j].l；如果先吃j，那么损失的时间是stone[i].l*stone[j].s。根据这个进行排序。

排序之后，我们就能保证每次取的时候，都将流量损失最大的石头给吃了。之后，吃哪个石头，就看我们怎么选了，因为一个石头可能它的能量比较大，但是它又比较浪费时间，这时候，就需要我们进行权衡。（其实这个和背包问题比较像，每次往背包里放从西的时候，它的价值可能比较大，但是它可能非常浪费空间。）。其实，在排序之后，它是0,1背包问题，能用动态规划解决。


时间复杂度也是O(N)*O(10000)，空间复杂度为O(10000)

[代码 github](https://github.com/CrowFea/CodeRepo/tree/master/KickStart/2019%20B)

### Diverse SubArray
自己做的时候思路是：使用一个map类型的二维数组，dp[l][r]记录从l到r的出现的每个元素的次数，每一次循环计算当前能带走的最大的值。因为新加入的元素可认为是前面的序列再加一，就可以动态规划解决。又因为每一行后面的元素的值只与前面的元素有关，所以可以将二维数组压缩到一维，一个n空间的数组。时间复杂度为O(N*N/2),空间复杂度为O(N)。注意可以进行剪枝，当当前的最大值大于后面剩下没遍历的元素时，直接返回。可以过第一个case。

第二个case显示MLE，超过了内存限制。于是我将数组又压缩为两个map，只记录当前的变量。结果是TLE...看来需要时间短于平方时间的算法。

答案提示用线段树。

[代码 github](https://github.com/CrowFea/CodeRepo/tree/master/KickStart/2019%20B)
